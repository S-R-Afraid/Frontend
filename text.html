<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <title>3D ç­‰é«˜çº¿ç”Ÿæˆå™¨ (æ”¯æŒé¢œè‰²é…ç½®)</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            color: #fff;
            font-family: sans-serif;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: block;
        }

        /* æ§åˆ¶é¢æ¿æ ·å¼ */
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(20, 20, 20, 0.9);
            padding: 20px;
            border-radius: 8px;
            pointer-events: auto;
            width: 320px;
            border: 1px solid #444;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
        }

        .control-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-size: 13px;
            color: #aaa;
        }

        input[type="range"] {
            width: 100%;
            cursor: pointer;
            accent-color: #007bff;
        }

        /* é¢œè‰²æŒ‰é’®æ ·å¼ */
        .color-btn-group {
            display: flex;
            gap: 5px;
            margin-top: 5px;
        }

        .color-btn {
            flex: 1;
            height: 30px;
            border: 1px solid #555;
            border-radius: 4px;
            cursor: pointer;
            transition: transform 0.1s;
        }

        .color-btn:hover {
            transform: scale(1.05);
            border-color: #fff;
        }

        .active-btn {
            border: 2px solid #fff;
            box-shadow: 0 0 8px rgba(255, 255, 255, 0.5);
        }

        button#regenerate {
            width: 100%;
            padding: 10px;
            background: #007bff;
            border: none;
            color: white;
            cursor: pointer;
            border-radius: 4px;
            font-size: 14px;
            font-weight: bold;
            margin-top: 10px;
        }

        button#regenerate:hover {
            background: #0056b3;
        }

        .hint {
            font-size: 12px;
            color: #666;
            margin-top: 15px;
            text-align: center;
            border-top: 1px solid #333;
            padding-top: 10px;
        }
    </style>
    <!-- å¼•å…¥ Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>
</head>

<body>

    <div id="controls">
        <h3>ç­‰é«˜çº¿é¢œè‰²ä¸å½¢æ€</h3>

        <div class="control-group">
            <label>é¢„è®¾é…è‰²æ–¹æ¡ˆ</label>
            <div class="color-btn-group" id="color-presets">
                <!-- æŒ‰é’®å°†ç”± JS åŠ¨æ€ç”Ÿæˆ -->
            </div>
        </div>

        <div class="control-group">
            <label>ç­‰é«˜çº¿å¯†åº¦: <span id="val-density">4</span></label>
            <input type="range" id="density" min="1" max="15" step="0.5" value="4">
        </div>

        <div class="control-group">
            <label>å´å²–ç¨‹åº¦ (Scale): <span id="val-scale">60</span></label>
            <input type="range" id="scale" min="20" max="150" value="60">
        </div>
        <div class="control-group">
            <label>åœ°å½¢é«˜åº¦ (Amplitude): <span id="val-height">30</span></label>
            <input type="range" id="height" min="10" max="100" value="30">
        </div>

        <button id="regenerate">åˆ·æ–°åœ°å½¢ç§å­</button>
        <div class="hint">ğŸ–±ï¸ å·¦é”®æ—‹è½¬ | å³é”®å¹³ç§» | æ»šè½®ç¼©æ”¾</div>
    </div>

    <div id="canvas-container"></div>

    <script>
        /**
         * å·¥å…·ç±»ï¼šç”Ÿæˆæ¸å˜çº¹ç†
         * å°†é¢œè‰²æ•°ç»„è½¬æ¢ä¸º Three.js å¯ç”¨çš„ Texture
         */
        class GradientTextureGenerator {
            static create(colors) {
                // åˆ›å»ºä¸€ä¸ª 256x1 çš„ Canvas
                const canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 1;
                const ctx = canvas.getContext('2d');

                // å¦‚æœåªæœ‰ä¸€ä¸ªé¢œè‰²ï¼Œç›´æ¥å¡«å……
                if (colors.length === 1) {
                    ctx.fillStyle = colors[0];
                    ctx.fillRect(0, 0, 256, 1);
                } else {
                    // åˆ›å»ºçº¿æ€§æ¸å˜
                    const gradient = ctx.createLinearGradient(0, 0, 256, 0);
                    colors.forEach((color, index) => {
                        // è®¡ç®—æ¯ä¸ªé¢œè‰²çš„ä½ç½® (0.0 ~ 1.0)
                        const stop = index / (colors.length - 1);
                        gradient.addColorStop(stop, color);
                    });
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, 256, 1);
                }

                // ç”Ÿæˆ Texture
                const texture = new THREE.CanvasTexture(canvas);
                texture.wrapS = THREE.ClampToEdgeWrapping;
                texture.wrapT = THREE.ClampToEdgeWrapping;
                // å…³é”®ï¼šç¦ç”¨ mipmap ä»¥ä¿è¯é¢œè‰²å‡†ç¡®
                texture.minFilter = THREE.LinearFilter;
                texture.magFilter = THREE.LinearFilter;
                return texture;
            }
        }

        /**
         * ç¬¬ä¸€éƒ¨åˆ†ï¼šåœ°å½¢æ•°æ®ç”Ÿæˆå™¨ (TerrainDataGenerator)
         */
        class TerrainDataGenerator {
            constructor(width, depth, options = {}) {
                this.width = width;
                this.depth = depth;
                this.seed = options.seed || Math.random();
                this.roughness = options.roughness || 50;
                this.amplitude = options.amplitude || 20;
                this.simplex = new SimplexNoise(this.seed.toString());

                // è®°å½•å½“å‰ç”Ÿæˆçš„æœ€å¤§æœ€å°é«˜åº¦ï¼Œç”¨äºå½’ä¸€åŒ–é¢œè‰²
                this.minH = 0;
                this.maxH = 0;
            }

            // é¢„è®¡ç®—æ‰€æœ‰ç‚¹çš„é«˜åº¦ï¼Œä»¥ä¾¿å‡†ç¡®è·å– min/max
            generateHeightMap(segments) {
                const data = [];
                let min = Infinity;
                let max = -Infinity;

                for (let i = 0; i <= segments; i++) {
                    for (let j = 0; j <= segments; j++) {
                        const u = i / segments;
                        const v = j / segments;
                        const x = u * this.width;
                        const z = v * this.depth;

                        // å åŠ ä¸‰å±‚å™ªå£°ä»¥è·å¾—ä¸°å¯Œç»†èŠ‚
                        let y = 0;
                        y += this.simplex.noise2D(x / this.roughness, z / this.roughness) * this.amplitude;
                        y += this.simplex.noise2D(x / (this.roughness * 0.5), z / (this.roughness * 0.5)) * (this.amplitude * 0.5);
                        y += this.simplex.noise2D(x / (this.roughness * 0.25), z / (this.roughness * 0.25)) * (this.amplitude * 0.1);

                        if (y < min) min = y;
                        if (y > max) max = y;
                        data.push(y);
                    }
                }
                this.minH = min;
                this.maxH = max;
                return data;
            }

            updateConfig(options) {
                if (options.seed !== undefined) {
                    this.seed = options.seed;
                    this.simplex = new SimplexNoise(this.seed.toString());
                }
                if (options.roughness !== undefined) this.roughness = options.roughness;
                if (options.amplitude !== undefined) this.amplitude = options.amplitude;
            }
        }

        /**
         * ç¬¬äºŒéƒ¨åˆ†ï¼šç­‰é«˜çº¿å¯è§†åŒ–å™¨
         */
        class ContourVisualizer {
            constructor(containerId, terrainGenerator, options = {}) {
                this.container = document.getElementById(containerId);
                this.terrain = terrainGenerator;
                this.density = options.density || 4.0;
                this.thickness = options.thickness || 0.1;

                // é»˜è®¤é¢œè‰²
                this.colorArray = options.colors || ['#ffffff'];

                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.controls = null;
                this.mesh = null;
                this.uniforms = null;

                this.initThreeJS();
                this.createTerrainMesh();
                this.animate();

                window.addEventListener('resize', () => this.onResize(), false);
            }

            initThreeJS() {
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x050505);

                const aspect = this.container.clientWidth / this.container.clientHeight;
                this.camera = new THREE.PerspectiveCamera(45, aspect, 0.1, 2000);
                this.camera.position.set(0, 120, 160);

                this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.container.appendChild(this.renderer.domElement);

                this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                this.controls.dampingFactor = 0.05;
                this.controls.autoRotate = false;
            }

            // æ ¸å¿ƒï¼šè®¾ç½®é¢œè‰²æ•°ç»„æ¥å£
            setColors(colors) {
                this.colorArray = colors;
                const newTexture = GradientTextureGenerator.create(colors);

                if (this.uniforms) {
                    this.uniforms.uGradientTexture.value = newTexture;
                }
            }

            createTerrainMesh() {
                if (this.mesh) {
                    this.scene.remove(this.mesh);
                    this.mesh.geometry.dispose();
                    this.mesh.material.dispose();
                }

                const segments = 200; // ç½‘æ ¼ç²¾åº¦
                const geometry = new THREE.PlaneGeometry(this.terrain.width, this.terrain.depth, segments, segments);

                // 1. è·å–é«˜åº¦æ•°æ®
                const heightData = this.terrain.generateHeightMap(segments);
                const positionAttribute = geometry.attributes.position;

                for (let i = 0; i < positionAttribute.count; i++) {
                    positionAttribute.setZ(i, heightData[i]);
                }

                geometry.computeVertexNormals();

                // 2. ç”Ÿæˆåˆå§‹æ¸å˜çº¹ç†
                const gradTexture = GradientTextureGenerator.create(this.colorArray);

                // 3. Shader é…ç½®
                this.uniforms = {
                    uGradientTexture: { value: gradTexture },
                    uLines: { value: 10.0 / this.density }, // é—´è·
                    uThickness: { value: this.thickness },
                    uMinHeight: { value: this.terrain.minH }, // ä¼ å…¥æœ€ä½ç‚¹
                    uMaxHeight: { value: this.terrain.maxH }  // ä¼ å…¥æœ€é«˜ç‚¹
                };

                const material = new THREE.ShaderMaterial({
                    uniforms: this.uniforms,
                    transparent: true,
                    side: THREE.DoubleSide,
                    vertexShader: `
                varying float vHeight;
                void main() {
                    vHeight = position.z;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
                    fragmentShader: `
                uniform sampler2D uGradientTexture; // æ¸å˜çº¹ç†
                uniform float uLines;
                uniform float uThickness;
                uniform float uMinHeight;
                uniform float uMaxHeight;
                
                varying float vHeight;

                void main() {
                    // 1. è®¡ç®—ç­‰é«˜çº¿é€»è¾‘
                    float linePhase = fract(vHeight / uLines);
                    float halfThick = uThickness * 0.5;
                    
                    // å¦‚æœä¸æ˜¯ç­‰é«˜çº¿åŒºåŸŸï¼Œä¸¢å¼ƒ
                    if (linePhase > halfThick && linePhase < (1.0 - halfThick)) {
                        discard;
                    }

                    // 2. é¢œè‰²é‡‡æ ·é€»è¾‘
                    // å°†å½“å‰é«˜åº¦å½’ä¸€åŒ–åˆ° 0.0 ~ 1.0
                    float normalizedH = (vHeight - uMinHeight) / (uMaxHeight - uMinHeight);
                    // é’³åˆ¶é˜²æ­¢æº¢å‡º
                    normalizedH = clamp(normalizedH, 0.0, 1.0); 
                    
                    // ä»çº¹ç†é‡‡æ ·é¢œè‰² (yåæ ‡å–0.5å³å¯)
                    vec4 color = texture2D(uGradientTexture, vec2(normalizedH, 0.5));

                    gl_FragColor = color;
                }
            `
                });

                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.rotation.x = -Math.PI / 2;
                this.scene.add(this.mesh);

                // å¯é€‰ï¼šæ·»åŠ ä¸€ä¸ªå¤–æ¡†è¾…åŠ©çº¿
                // const helper = new THREE.BoxHelper(this.mesh, 0x333333);
                // this.scene.add(helper);
            }

            updateParams(density) {
                if (this.uniforms) {
                    this.uniforms.uLines.value = 10.0 / density;
                }
            }

            refreshTerrain() {
                this.createTerrainMesh();
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                this.controls.update();
                this.renderer.render(this.scene, this.camera);
            }

            onResize() {
                const width = this.container.clientWidth;
                const height = this.container.clientHeight;
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(width, height);
            }
        }

        // ================= é€»è¾‘æ§åˆ¶ä¸é…ç½® =================

        const terrainGen = new TerrainDataGenerator(200, 200, {
            seed: Math.random(),
            roughness: 60,
            amplitude: 30
        });

        // é»˜è®¤ä½¿ç”¨"é»‘å®¢ç»¿"çº¯è‰²
        const visualizer = new ContourVisualizer('canvas-container', terrainGen, {
            density: 4,
            colors: ['#00ff88']
        });

        // --- UI äº¤äº’é€»è¾‘ ---

        // 1. å®šä¹‰é…è‰²æ–¹æ¡ˆ
        const colorSchemes = [
            { name: "Neon Green", colors: ["#00ff00"], style: "background:#00ff00" },
            { name: "Heatmap", colors: ["#0000ff", "#00ffff", "#00ff00", "#ffff00", "#ff0000"], style: "background: linear-gradient(90deg, blue, cyan, lime, yellow, red)" },
            { name: "Ocean", colors: ["#020024", "#090979", "#00d4ff"], style: "background: linear-gradient(90deg, #020024, #090979, #00d4ff)" },
            { name: "Cyberpunk", colors: ["#ff00cc", "#3333ff"], style: "background: linear-gradient(90deg, #ff00cc, #3333ff)" },
            { name: "Gold", colors: ["#bf953f", "#fcf6ba", "#bf953f", "#ff0000", "#ffff00", "#fcf6ba", "#bf953f"], style: "background: linear-gradient(90deg, #bf953f, #fcf6ba, #bf953f)" }
        ];

        // 2. ç”Ÿæˆé¢œè‰²æŒ‰é’®
        const presetContainer = document.getElementById('color-presets');
        colorSchemes.forEach((scheme, index) => {
            const btn = document.createElement('div');
            btn.className = 'color-btn';
            btn.style = scheme.style;
            btn.title = scheme.name;
            if (index === 0) btn.classList.add('active-btn'); // é»˜è®¤é€‰ä¸­ç¬¬ä¸€ä¸ª

            btn.addEventListener('click', () => {
                // UI æ›´æ–°
                document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('active-btn'));
                btn.classList.add('active-btn');

                // æ ¸å¿ƒè°ƒç”¨ï¼šä¼ é€’é¢œè‰²æ•°ç»„
                visualizer.setColors(scheme.colors);
            });

            presetContainer.appendChild(btn);
        });

        // 3. å…¶ä»–å‚æ•°ç»‘å®š
        const inputs = {
            density: document.getElementById('density'),
            scale: document.getElementById('scale'),
            height: document.getElementById('height'),
            btn: document.getElementById('regenerate')
        };
        const labels = {
            density: document.getElementById('val-density'),
            scale: document.getElementById('val-scale'),
            height: document.getElementById('val-height')
        };

        inputs.density.addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            labels.density.innerText = val;
            visualizer.updateParams(val);
        });

        function regenerate() {
            const scale = parseFloat(inputs.scale.value);
            const height = parseFloat(inputs.height.value);

            labels.scale.innerText = scale;
            labels.height.innerText = height;

            terrainGen.updateConfig({
                seed: Math.random(), // æ¯æ¬¡ç‚¹å‡»ç”Ÿæˆéšæœºç§å­
                roughness: scale,
                amplitude: height
            });

            visualizer.refreshTerrain();
        }

        inputs.btn.addEventListener('click', regenerate);
        inputs.scale.addEventListener('change', regenerate);
        inputs.height.addEventListener('change', regenerate);

    </script>
</body>

</html>