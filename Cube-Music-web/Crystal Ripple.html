<!DOCTYPE html>
<html lang="zh">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Parametric Crystal Ripple Grid</title>

  <style>
    :root {
      --bg: #080808;
      --panel: #111;
    }

    body {
      margin: 0;
      background: var(--bg);
      color: #aaa;
      font-family: system-ui, sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      -webkit-user-select: none;
      user-select: none;
    }

    canvas {
      background: #000;
      border-radius: 6px;
    }
  </style>
</head>

<body>
  <canvas id="grid"></canvas>

  <script>
    /* =========================================================
       ====== ① 全局可调参数（你主要改这里） ======
       ========================================================= */

    /* ---- 网格与节奏 ---- */
    const ROWS = 16;
    const COLS = 16;
    const BPM = 120;     // 播放速度（越大越快）
    const CANVAS_SIZE = 600;

    /* ---- 波纹强度 ---- */
    const RIPPLE_CLICK = 400;
    const RIPPLE_PLAY = 600;
    const RIPPLE_HOVER = 100;

    /* ---- 波纹颜色（叠加用） ---- */
    const RIPPLE_COLOR_CLICK = [80, 180, 255];
    const RIPPLE_COLOR_PLAY = [255, 255, 255];
    const RIPPLE_COLOR_HOVER = [60, 120, 180];

    /* ---- 方格颜色 ---- */
    const CELL_ACTIVE_COLOR = [255, 255, 255];
    const CELL_INACTIVE_COLOR = [20, 24, 30];

    /* ---- 波纹物理 ---- */
    const DAMPING = 0.7;
    const PHYSICS_SKIP = 3;

    /* ========================================================= */

    const GAP = 2;
    const CELL_SIZE = (CANVAS_SIZE - GAP * (COLS + 1)) / COLS;

    /* Canvas 初始化 */
    const canvas = document.getElementById("grid");
    const ctx = canvas.getContext("2d");
    const dpr = devicePixelRatio || 1;
    canvas.width = CANVAS_SIZE * dpr;
    canvas.height = CANVAS_SIZE * dpr;
    canvas.style.width = CANVAS_SIZE + "px";
    canvas.style.height = CANVAS_SIZE + "px";
    ctx.scale(dpr, dpr);

    /* 状态 */
    const grid = Array.from({ length: ROWS }, () => Array(COLS).fill(false));
    let ripplePrev = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
    let rippleCurr = Array.from({ length: ROWS }, () => Array(COLS).fill(0));

    let frame = 0;
    let visualCol = -1;

    /* 音频 */
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const midiTable = Array.from({ length: ROWS }, (_, i) => 84 - i * 2);

    const midiToFreq = m => 440 * Math.pow(2, (m - 69) / 12);

    function playNote(freq, t = audioCtx.currentTime) {
      const gain = audioCtx.createGain();
      gain.gain.setValueAtTime(0.0001, t);
      gain.gain.exponentialRampToValueAtTime(0.3, t + 0.004);
      gain.gain.exponentialRampToValueAtTime(0.0001, t + 0.5);

      const hp = audioCtx.createBiquadFilter();
      hp.type = "highpass";
      hp.frequency.value = freq * 2.2;

      [1, 2.01, 3.98].forEach((m, i) => {
        const o = audioCtx.createOscillator();
        o.type = "sine";
        o.frequency.value = freq * m;
        o.detune.value = i === 1 ? 3 : i === 2 ? -4 : 0;
        o.connect(hp);
        o.start(t);
        o.stop(t + 0.55);
      });

      hp.connect(gain);
      gain.connect(audioCtx.destination);
    }

    /* 波纹 */
    function triggerRipple(x, y, strength) {
      if (x < 0 || y < 0 || x >= COLS || y >= ROWS) return;
      ripplePrev[y][x] += strength;
    }

    function updateRipples() {
      for (let y = 0; y < ROWS; y++) {
        for (let x = 0; x < COLS; x++) {
          let v = (
            ripplePrev[y][Math.max(0, x - 1)] +
            ripplePrev[y][Math.min(COLS - 1, x + 1)] +
            ripplePrev[Math.max(0, y - 1)][x] +
            ripplePrev[Math.min(ROWS - 1, y + 1)][x]
          ) / 2;
          v -= rippleCurr[y][x];
          v *= DAMPING;
          rippleCurr[y][x] = v;
        }
      }
      [ripplePrev, rippleCurr] = [rippleCurr, ripplePrev];
    }

    /* 鼠标交互 */
    let isDown = false;
    let drawMode = true;
    let lastCell = { x: -1, y: -1 };

    function cellFromEvent(e) {
      const r = canvas.getBoundingClientRect();
      return {
        x: Math.floor((e.clientX - r.left) / (r.width / COLS)),
        y: Math.floor((e.clientY - r.top) / (r.height / ROWS))
      };
    }

    canvas.addEventListener("mousedown", e => {
      const c = cellFromEvent(e);
      isDown = true;
      drawMode = !grid[c.y]?.[c.x];
      if (audioCtx.state === "suspended") audioCtx.resume();
      grid[c.y][c.x] = drawMode;
      triggerRipple(c.x, c.y, RIPPLE_CLICK);
    });

    canvas.addEventListener("mousemove", e => {
      const c = cellFromEvent(e);
      if (c.x === lastCell.x && c.y === lastCell.y) return;
      lastCell = c;

      if (isDown) {
        grid[c.y][c.x] = drawMode;
        triggerRipple(c.x, c.y, RIPPLE_CLICK);
      } else {
        triggerRipple(c.x, c.y, RIPPLE_HOVER);
      }
    });

    window.addEventListener("mouseup", () => {
      isDown = false;
      lastCell = { x: -1, y: -1 };
    });

    /* 调度 */
    let col = 0;
    let nextTime = audioCtx.currentTime + 0.1;

    function scheduler() {
      while (nextTime < audioCtx.currentTime + 0.1) {
        const playCol = col;
        setTimeout(() => {
          visualCol = playCol;
          for (let r = 0; r < ROWS; r++) {
            if (grid[r][playCol]) {
              playNote(midiToFreq(midiTable[r]));
              triggerRipple(playCol, r, RIPPLE_PLAY);
            }
          }
        }, (nextTime - audioCtx.currentTime) * 1000);

        nextTime += (60 / BPM) / 4;
        col = (col + 1) % COLS;
      }
      requestAnimationFrame(scheduler);
    }

    /* 渲染 */
    function draw() {
      frame++;
      if (frame % PHYSICS_SKIP === 0) updateRipples();

      ctx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);

      for (let y = 0; y < ROWS; y++) {
        for (let x = 0; x < COLS; x++) {
          const wave = ripplePrev[y][x];
          const base = grid[y][x] ? CELL_ACTIVE_COLOR : CELL_INACTIVE_COLOR;

          const r = Math.min(255, base[0] + wave * 0.3);
          const g = Math.min(255, base[1] + wave * 0.3);
          const b = Math.min(255, base[2] + wave * 0.3);

          const s = CELL_SIZE * Math.max(0.3, 1 + wave / 800);
          const px = x * (CELL_SIZE + GAP) + GAP + CELL_SIZE / 2;
          const py = y * (CELL_SIZE + GAP) + GAP + CELL_SIZE / 2;

          ctx.save();
          ctx.translate(px, py);
          ctx.fillStyle = `rgb(${r},${g},${b})`;
          ctx.fillRect(-s / 2, -s / 2, s, s);
          ctx.restore();
        }
      }

      requestAnimationFrame(draw);
    }

    scheduler();
    draw();
  </script>
</body>

</html>