<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />
  <title>Text Animation</title>
  <style>
    .text_footer {
      font-size: 24px;
      color: rgb(86, 162, 255);
      /* 设置文本颜色为红色 */
    }

    body {
      background:
        linear-gradient(-45deg, #000000, #425f9c, #71429c, #000000);
      background-size: 7% 700%;
      animation: gradientBG 15s ease infinite;
    }

    @keyframes gradientBG {
      0% {
        background-position: 0% 0%;
      }

      50% {
        background-position: 100% 0%;
      }

      100% {
        background-position: 0% 0%;
      }
    }
  </style>
</head>

<body>
  <p>
    <center>
      <div class="text_footer" style="display: inline"></div>
    </center>
  </p>
</body>
<style>
  .text_footer {
    font-size: 24px;
  }
</style>
<script type="text/javascript">
  obfu_data_footer = {
    delay: 0,
    start_time: 40,
    end_time: 40,
    disp_time: 2000,
    loop: true,
    obfu_chars: "░▒▓▖▗▘▙▚▛▜▝▞▟",
    phrases: [
      "文于止墨",
      "热爱创造的极地空想家",
    ],
  };

  var obfuData = obfu_data_footer;

  const delay = obfuData.delay;
  const start_time = obfuData.start_time;
  const end_time = obfuData.end_time;
  const disp_time = obfuData.disp_time;
  const loop = obfuData.loop;
  const obfu_chars = obfuData.obfu_chars;
  const phrases = obfuData.phrases;

  class TextScramble {
    constructor(el) {
      this.el = el;
      this.chars = obfu_chars;
      this.update = this.update.bind(this);
    }
    setText(newText) {
      const oldText = this.el.innerText;
      const length = Math.max(oldText.length, newText.length);
      const promise = new Promise((resolve) => (this.resolve = resolve));
      this.queue = [];
      for (let i = 0; i < length; i++) {
        const from = oldText[i] || "";
        const to = newText[i] || "";
        const start = Math.floor(Math.random() * start_time);
        const end = start + Math.floor(Math.random() * end_time);
        this.queue.push({ from, to, start, end });
      }
      cancelAnimationFrame(this.frameRequest);
      this.frame = 0;
      this.update();
      return promise;
    }
    update() {
      let output = "";
      let complete = 0;
      for (let i = 0, n = this.queue.length; i < n; i++) {
        let { from, to, start, end, char } = this.queue[i];
        if (this.frame >= end) {
          complete++;
          output += to;
        } else if (this.frame >= start) {
          if (!char || Math.random() < 0.28) {
            char = this.randomChar();
            this.queue[i].char = char;
          }
          output += `<span class="dud">${char}</span>`;
        } else {
          output += from;
        }
      }
      this.el.innerHTML = output;
      if (complete === this.queue.length) {
        this.resolve();
      } else {
        this.frameRequest = requestAnimationFrame(this.update);
        this.frame++;
      }
    }
    randomChar() {
      return this.chars[Math.floor(Math.random() * this.chars.length)];
    }
  }

  const el = document.querySelector(".text_footer");
  const fx = new TextScramble(el);

  let counter = 0;
  const next = () => {
    fx.setText(phrases[counter]).then(() => {
      setTimeout(next, disp_time);
    });
    if (!loop & (counter < phrases.length)) {
      counter = counter + 1;
    } else if (counter <= phrases.length) {
      counter = (counter + 1) % phrases.length;
    }
  };

  setTimeout(next, delay);
</script>

</html>