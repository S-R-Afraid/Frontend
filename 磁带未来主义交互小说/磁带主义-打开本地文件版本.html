<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SYSTEM_OVERRIDE // 磁带未来 v5.1 智能加载版</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    
    <style>
        /* --- 样式部分保持 v5.0 不变 --- */
        :root {
            --phosphor-main: #ffb000;
            --phosphor-dim: #996a00;
            --bg-color: #0a0a0a;
            --screen-bg: #110d00;
            --scanline-color: rgba(0, 0, 0, 0.5);
            --crt-curvature: inset 0 0 100px rgba(0,0,0,0.9);
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--phosphor-main);
            font-family: 'VT323', monospace;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            user-select: none;
            cursor: pointer;
        }

        .crt-container {
            width: 90vw;
            height: 80vh;
            max-width: 800px;
            background-color: var(--screen-bg);
            border: 20px solid #222;
            border-radius: 20px;
            position: relative;
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
            overflow: hidden;
            transform: perspective(1000px); 
        }

        .screen {
            padding: 40px;
            height: 100%;
            box-sizing: border-box;
            position: relative;
            z-index: 2;
            display: flex;
            flex-direction: column;
            font-size: 1.4rem;
            line-height: 1.2;
            text-shadow: 0 0 5px var(--phosphor-dim);
        }

        /* CRT 特效 */
        .scanlines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to bottom, rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%);
            background-size: 100% 4px;
            z-index: 10;
            pointer-events: none;
        }

        .scan-beam {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            background: linear-gradient(to bottom, transparent 0%, rgba(255, 255, 255, 0.05) 50%, transparent 100%);
            background-size: 100% 20%;
            background-repeat: no-repeat;
            animation: beam-scan 8s linear infinite;
            pointer-events: none;
            mix-blend-mode: overlay;
        }

        .flicker-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 176, 0, 0.02);
            z-index: 11;
            pointer-events: none;
            animation: flicker 0.15s infinite;
        }

        .vignette {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            box-shadow: var(--crt-curvature);
            z-index: 12;
            pointer-events: none;
        }

        @keyframes beam-scan { 0% { background-position: 0 -20%; } 100% { background-position: 0 120%; } }
        @keyframes flicker { 0% { opacity: 0.9; } 50% { opacity: 1; } 100% { opacity: 0.95; } }

        .header {
            border-bottom: 2px solid var(--phosphor-main);
            padding-bottom: 10px;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        #story-text {
            flex-grow: 1;
            overflow-y: auto;
            margin-bottom: 20px;
            white-space: pre-wrap;
        }

        .char-span { text-shadow: 0 0 5px currentColor; }

        #choices {
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-height: 50px;
        }

        button {
            background: transparent;
            border: 2px solid var(--phosphor-dim);
            color: var(--phosphor-main);
            font-family: 'VT323', monospace;
            font-size: 1.2rem;
            padding: 10px 20px;
            cursor: pointer;
            text-align: left;
            transition: all 0.1s;
            text-transform: uppercase;
            position: relative;
        }
        button:hover {
            background-color: var(--phosphor-main);
            color: var(--bg-color);
            border-color: var(--phosphor-main);
            box-shadow: 0 0 15px var(--phosphor-main);
        }
        button::before { content: "> "; }

        /* 图片拉伸样式 */
        .terminal-img-container {
            width: 100%;
            height: 350px; /* 固定高度 */
            margin-bottom: 15px;
            position: relative;
            overflow: hidden;
            border: 2px solid var(--phosphor-dim);
            box-shadow: 0 0 10px var(--phosphor-dim);
            animation: img-scan-in 0.8s cubic-bezier(0.23, 1, 0.32, 1) forwards;
            display: none; 
        }

        .terminal-img {
            width: 100%;
            height: 100%;
            display: block;
            object-fit: fill; /* 强制拉伸 */
            image-rendering: pixelated; 
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            filter: contrast(1.3) saturate(0.7) sepia(0.3) brightness(0.8);
        }

        .terminal-img-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(0deg, rgba(0,0,0,0.2) 0px, rgba(0,0,0,0.2) 1px, transparent 1px, transparent 2px);
            pointer-events: none;
            z-index: 5;
        }

        @keyframes img-scan-in {
            0% { height: 0; opacity: 0.5; filter: brightness(2); }
            100% { height: 350px; opacity: 1; filter: contrast(1.3) saturate(0.7) sepia(0.3) brightness(0.8); }
        }

        ::-webkit-scrollbar { width: 10px; }
        ::-webkit-scrollbar-track { background: var(--screen-bg); }
        ::-webkit-scrollbar-thumb { background: var(--phosphor-dim); border: 1px solid var(--screen-bg); }

        .cursor::after {
            content: '█';
            animation: blink 1s step-end infinite;
            margin-left: 5px;
        }
        @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0; } }

        .tape-label {
            position: absolute;
            bottom: -50px;
            right: 20px;
            background: #eee;
            color: #000;
            padding: 5px 15px;
            transform: rotate(-2deg);
            font-family: sans-serif;
            font-weight: bold;
            font-size: 12px;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.5);
            z-index: 20;
            opacity: 0.8;
        }
    </style>
</head>
<body>

    <input type="file" id="json-loader" accept=".json" style="display: none;">

    <div class="crt-container">
        <div class="scanlines"></div>
        <div class="scan-beam"></div>
        <div class="flicker-overlay"></div>
        <div class="vignette"></div>
        <div class="tape-label">MIXTAPE: SYSTEM_BOOT</div>
        
        <div class="screen">
            <div class="header">
                <span>TERMINAL_ID: 88-X</span>
                <span id="clock">00:00:00</span>
            </div>
            
            <div id="story-text" class="cursor"></div>
            
            <div id="choices"></div>
        </div>
    </div>

    <script>
        // --- 全局核心变量 ---
        let storyNodes = {}; 
        let typeQueue = [];
        let typeIndex = 0;
        let typeCallback = null;
        let typeTimer = null;
        let isTyping = false;

        const textElement = document.getElementById('story-text');
        const choicesElement = document.getElementById('choices');
        const fileInput = document.getElementById('json-loader');

        // 时钟
        function updateClock() {
            const now = new Date();
            document.getElementById('clock').innerText = now.toLocaleTimeString('en-US', {hour12: false});
        }
        setInterval(updateClock, 1000);
        updateClock();

        // --- 辅助函数：查找配对的右括号 ---
        function findClosingBrace(str, startIndex) {
            let depth = 0;
            for (let k = startIndex; k < str.length; k++) {
                if (str[k] === '{') depth++;
                if (str[k] === '}') {
                    depth--; 
                    if (depth === 0) return k;
                }
            }
            return -1;
        }

        // --- 核心：递归解析器 (支持嵌套样式) ---
        /**
         * @param {string} text 要解析的文本
         * @param {object} currentStyle 当前继承的样式状态 { color: string, decorations: Set }
         */
        function parseScript(text, currentStyle = { color: null, decorations: new Set() }) {
            const queue = [];
            let i = 0;
            const len = text.length;

            while (i < len) {
                // 1. 处理停顿 \.
                if (text.startsWith('\\.', i)) {
                    queue.push({ type: 'wait', ms: 500 });
                    i += 2;
                    continue;
                }
                
                // 2. 处理颜色 \C[color]{content}
                if (text.startsWith('\\C[', i)) {
                    const colorEnd = text.indexOf(']', i);
                    if (colorEnd > -1 && text[colorEnd + 1] === '{') {
                        const contentEnd = findClosingBrace(text, colorEnd + 1);
                        if (contentEnd > -1) {
                            const colorCode = text.substring(i + 3, colorEnd);
                            const innerContent = text.substring(colorEnd + 2, contentEnd);
                            
                            // 创建新的样式状态（继承旧的 decoration，更新 color）
                            const newStyle = {
                                color: colorCode,
                                decorations: new Set(currentStyle.decorations)
                            };

                            // 递归解析内部内容
                            const innerQueue = parseScript(innerContent, newStyle);
                            queue.push(...innerQueue);

                            i = contentEnd + 1;
                            continue;
                        }
                    }
                }

                // 3. 处理删除线 \-{content}
                if (text.startsWith('\\-{', i)) {
                    const contentEnd = findClosingBrace(text, i + 2);
                    if (contentEnd > -1) {
                        const innerContent = text.substring(i + 3, contentEnd);
                        
                        // 添加 line-through 到 decoration 集合
                        const newDecorations = new Set(currentStyle.decorations);
                        newDecorations.add('line-through');
                        
                        const newStyle = {
                            color: currentStyle.color,
                            decorations: newDecorations
                        };

                        const innerQueue = parseScript(innerContent, newStyle);
                        queue.push(...innerQueue);

                        i = contentEnd + 1;
                        continue;
                    }
                }

                // 4. 处理下划线 \_{content}
                if (text.startsWith('\\_{', i)) {
                    const contentEnd = findClosingBrace(text, i + 2);
                    if (contentEnd > -1) {
                        const innerContent = text.substring(i + 3, contentEnd);
                        
                        // 添加 underline 到 decoration 集合
                        const newDecorations = new Set(currentStyle.decorations);
                        newDecorations.add('underline');
                        
                        const newStyle = {
                            color: currentStyle.color,
                            decorations: newDecorations
                        };

                        const innerQueue = parseScript(innerContent, newStyle);
                        queue.push(...innerQueue);

                        i = contentEnd + 1;
                        continue;
                    }
                }

                // 5. 普通字符处理
                // 根据 currentStyle 生成 CSS 字符串
                let styleStr = "";
                if (currentStyle.color) {
                    styleStr += `color: ${currentStyle.color}; `;
                }
                if (currentStyle.decorations.size > 0) {
                    // CSS text-decoration 支持多个值，如 "underline line-through"
                    const decoStr = Array.from(currentStyle.decorations).join(' ');
                    styleStr += `text-decoration: ${decoStr};`;
                }

                queue.push({ 
                    type: 'char', 
                    char: text[i], 
                    style: styleStr 
                });
                i++;
            }
            
            return queue;
        }

        // --- 打字机引擎 (保持不变) ---
        function startTypewriter(queue, callback) {
            if (typeTimer) clearTimeout(typeTimer);
            typeQueue = queue;
            typeIndex = 0;
            typeCallback = callback;
            isTyping = true;
            processNext();
        }

        function processNext() {
            if (typeIndex >= typeQueue.length) {
                isTyping = false;
                if (typeCallback) typeCallback();
                return;
            }
            const item = typeQueue[typeIndex];
            typeIndex++;

            if (item.type === 'wait') {
                typeTimer = setTimeout(processNext, item.ms);
            } else if (item.type === 'char') {
                appendCharToScreen(item);
                textElement.scrollTop = textElement.scrollHeight;
                let speed = Math.random() * 30 + 10;
                if (['.', '?', '!', '\n'].includes(item.char)) speed += 200;
                typeTimer = setTimeout(processNext, speed);
            }
        }

        function appendCharToScreen(item) {
            const span = document.createElement('span');
            span.textContent = item.char;
            span.className = 'char-span';
            if (item.style) span.style.cssText = item.style;
            textElement.appendChild(span);
        }

        function instantFinish() {
            if (!isTyping) return;
            clearTimeout(typeTimer);
            while (typeIndex < typeQueue.length) {
                const item = typeQueue[typeIndex];
                typeIndex++;
                if (item.type === 'char') appendCharToScreen(item);
            }
            textElement.scrollTop = textElement.scrollHeight;
            isTyping = false;
            if (typeCallback) typeCallback();
        }

        // --- 节点显示 ---
        function showNode(nodeKey) {
            const node = storyNodes[nodeKey];
            if (!node) {
                console.error("Node missing:", nodeKey);
                const errQueue = parseScript(`\\C[red]{ERROR: SECTOR [${nodeKey}] NOT FOUND.}`);
                startTypewriter(errQueue);
                return;
            }

            textElement.innerHTML = "";
            choicesElement.innerHTML = "";

            // 处理图片
            if (node.image) {
                const imgContainer = document.createElement('div');
                imgContainer.className = 'terminal-img-container';
                imgContainer.style.display = 'block';

                const img = document.createElement('img');
                img.src = node.image; 
                img.className = 'terminal-img';
                
                img.onerror = function() {
                    imgContainer.style.display = 'none';
                    const errSpan = document.createElement('div');
                    errSpan.innerHTML = '<span style="color:red;font-size:0.8em;">[ERR: IMAGE_DATA_CORRUPT]</span>';
                    textElement.appendChild(errSpan);
                };

                const overlay = document.createElement('div');
                overlay.className = 'terminal-img-overlay';

                imgContainer.appendChild(img);
                imgContainer.appendChild(overlay);
                textElement.appendChild(imgContainer);
            }

            // 解析文本 (递归解析)
            const queue = parseScript(node.text);
            
            startTypewriter(queue, () => {
                if (node.options) {
                    node.options.forEach(option => {
                        const button = document.createElement('button');
                        button.innerText = option.text;
                        button.onclick = (e) => {
                            e.stopPropagation();
                            showNode(option.nextNode);
                        };
                        choicesElement.appendChild(button);
                    });
                }
                textElement.scrollTop = textElement.scrollHeight;
            });
        }

        // --- 加载逻辑 ---
        function initSystem() {
            const scanText = "SYSTEM ONLINE.\nINITIALIZING NET_PROTOCOL... \\.\\.\nSEARCHING FOR DATA CARTRIDGE...\\.";
            const queue = parseScript(scanText);
            startTypewriter(queue, () => {
                checkForLocalFile();
            });
        }

        function checkForLocalFile() {
            fetch('./磁带主义story.json')
                .then(response => {
                    if (!response.ok) throw new Error("404");
                    return response.json();
                })
                .then(data => {
                    showFoundUI(data);
                })
                .catch(err => {
                    showMissingUI();
                });
        }

        function showFoundUI(data) {
            // 测试嵌套样式是否生效
            const foundText = "\n\n\\C[#0f0]{SIGNAL DETECTED: \\_{ [STORY.JSON] } }\\.\nINTEGRITY CHECK: OK.";
            const queue = parseScript(foundText);
            
            startTypewriter(queue, () => {
                const btnAuto = document.createElement('button');
                btnAuto.innerText = "EXECUTE [AUTO LOAD]";
                btnAuto.onclick = (e) => {
                    e.stopPropagation();
                    storyNodes = data;
                    bootSequence();
                };
                
                const btnManual = document.createElement('button');
                btnManual.innerText = "MANUAL OVERRIDE [INSERT TAPE]";
                btnManual.onclick = (e) => {
                    e.stopPropagation();
                    fileInput.click();
                };

                choicesElement.appendChild(btnAuto);
                choicesElement.appendChild(btnManual);
                textElement.scrollTop = textElement.scrollHeight;
            });
        }

        function showMissingUI() {
            const missingText = "\n\n\\C[red]{NO CARTRIDGE DETECTED.}\\.\nPLEASE INSERT DATA MANUALLY.";
            const queue = parseScript(missingText);
            
            startTypewriter(queue, () => {
                const btnManual = document.createElement('button');
                btnManual.innerText = "INSERT TAPE [SELECT FILE]";
                btnManual.onclick = (e) => {
                    e.stopPropagation();
                    fileInput.click();
                };
                choicesElement.appendChild(btnManual);
                textElement.scrollTop = textElement.scrollHeight;
            });
        }

        fileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) return;

            textElement.innerText = "READING MAGNETIC TAPE...\nDECODING SECTORS...";
            choicesElement.innerHTML = ""; 

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const jsonContent = e.target.result;
                    storyNodes = JSON.parse(jsonContent);
                    setTimeout(bootSequence, 1000);
                } catch (err) {
                    textElement.innerHTML = "\\C[red]{FATAL ERROR: DATA CORRUPTED.}\\.\n无法解析 JSON 文件。";
                    const retryBtn = document.createElement('button');
                    retryBtn.innerText = "RETRY LOAD";
                    retryBtn.onclick = (ev) => {
                         ev.stopPropagation();
                         fileInput.click();
                    };
                    choicesElement.appendChild(retryBtn);
                    const errQueue = parseScript(textElement.innerText);
                    textElement.innerHTML = "";
                    startTypewriter(errQueue);
                }
            };
            reader.readAsText(file);
        });

        function bootSequence() {
            textElement.innerHTML = "";
            choicesElement.innerHTML = "";
            const bootText = "BIOS DATE 01/01/1985 14:22:56 VER 1.02\nCPU: NEC V20, SPEED: 8 MHz\n640K RAM SYSTEM... \\C[#0f0]{OK}\nLOADING CASSETTE INTERFACE...\\.\\.\\.";
            
            const queue = parseScript(bootText);
            startTypewriter(queue, () => {
                setTimeout(() => {
                    if (storyNodes['start']) {
                        showNode('start');
                    } else {
                        showNode(Object.keys(storyNodes)[0]);
                    }
                }, 1000);
            });
        }

        document.body.addEventListener('click', (e) => {
            if (e.target.tagName === 'BUTTON') return;
            if (isTyping) instantFinish();
        });

        window.onload = initSystem;
    </script>
</body>
</html>