<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SYSTEM_OVERRIDE // 磁带未来 JSON版</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">

    <style>
        /* --- 样式部分保持完全一致 --- */
        :root {
            --phosphor-main: #ffb000;
            --phosphor-dim: #996a00;
            --bg-color: #0a0a0a;
            --screen-bg: #110d00;
            --scanline-color: rgba(0, 0, 0, 0.5);
            --crt-curvature: inset 0 0 100px rgba(0, 0, 0, 0.9);
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--phosphor-main);
            font-family: 'VT323', monospace;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            user-select: none;
            cursor: pointer;
        }

        .crt-container {
            width: 90vw;
            height: 80vh;
            max-width: 800px;
            background-color: var(--screen-bg);
            border: 20px solid #222;
            border-radius: 20px;
            position: relative;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.8);
            overflow: hidden;
            transform: perspective(1000px);
        }

        .screen {
            padding: 40px;
            height: 100%;
            box-sizing: border-box;
            position: relative;
            z-index: 2;
            display: flex;
            flex-direction: column;
            font-size: 1.4rem;
            line-height: 1.2;
            text-shadow: 0 0 5px var(--phosphor-dim);
        }

        .scanlines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to bottom,
                    rgba(18, 16, 16, 0) 50%,
                    rgba(0, 0, 0, 0.25) 50%);
            background-size: 100% 4px;
            z-index: 10;
            pointer-events: none;
        }

        .scan-beam {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            background: linear-gradient(to bottom,
                    transparent 0%,
                    rgba(255, 255, 255, 0.05) 50%,
                    transparent 100%);
            background-size: 100% 20%;
            background-repeat: no-repeat;
            animation: beam-scan 8s linear infinite;
            pointer-events: none;
            mix-blend-mode: overlay;
        }

        .flicker-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 176, 0, 0.02);
            z-index: 11;
            pointer-events: none;
            animation: flicker 0.15s infinite;
        }

        .vignette {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            box-shadow: var(--crt-curvature);
            z-index: 12;
            pointer-events: none;
        }

        @keyframes beam-scan {
            0% {
                background-position: 0 -20%;
            }

            100% {
                background-position: 0 120%;
            }
        }

        @keyframes flicker {
            0% {
                opacity: 0.9;
            }

            50% {
                opacity: 1;
            }

            100% {
                opacity: 0.95;
            }
        }

        .header {
            border-bottom: 2px solid var(--phosphor-main);
            padding-bottom: 10px;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        #story-text {
            flex-grow: 1;
            overflow-y: auto;
            margin-bottom: 20px;
            white-space: pre-wrap;
        }

        .char-span {
            text-shadow: 0 0 5px currentColor;
        }

        #choices {
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-height: 50px;
        }

        button {
            background: transparent;
            border: 2px solid var(--phosphor-dim);
            color: var(--phosphor-main);
            font-family: 'VT323', monospace;
            font-size: 1.2rem;
            padding: 10px 20px;
            cursor: pointer;
            text-align: left;
            transition: all 0.1s;
            text-transform: uppercase;
            position: relative;
        }

        button:hover {
            background-color: var(--phosphor-main);
            color: var(--bg-color);
            border-color: var(--phosphor-main);
            box-shadow: 0 0 15px var(--phosphor-main);
        }

        button::before {
            content: "> ";
        }

        ::-webkit-scrollbar {
            width: 10px;
        }

        ::-webkit-scrollbar-track {
            background: var(--screen-bg);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--phosphor-dim);
            border: 1px solid var(--screen-bg);
        }

        .cursor::after {
            content: '█';
            animation: blink 1s step-end infinite;
            margin-left: 5px;
        }

        @keyframes blink {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0;
            }
        }

        .tape-label {
            position: absolute;
            bottom: -50px;
            right: 20px;
            background: #eee;
            color: #000;
            padding: 5px 15px;
            transform: rotate(-2deg);
            font-family: sans-serif;
            font-weight: bold;
            font-size: 12px;
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.5);
            z-index: 20;
            opacity: 0.8;
        }
    </style>
</head>

<body>

    <div class="crt-container">
        <div class="scanlines"></div>
        <div class="scan-beam"></div>
        <div class="flicker-overlay"></div>
        <div class="vignette"></div>
        <div class="tape-label">MIXTAPE: MEMORY_05</div>

        <div class="screen">
            <div class="header">
                <span>TERMINAL_ID: 88-X</span>
                <span id="clock">00:00:00</span>
            </div>

            <!-- 这里可以显示 loading -->
            <div id="story-text" class="cursor">INITIALIZING CONNECTION...<br></div>

            <div id="choices"></div>
        </div>
    </div>

    <script>
        // --- 全局变量 ---
        let storyNodes = {}; // 现在初始为空，等待加载
        let typeQueue = [];
        let typeIndex = 0;
        let typeCallback = null;
        let typeTimer = null;
        let isTyping = false;

        const textElement = document.getElementById('story-text');
        const choicesElement = document.getElementById('choices');

        function updateClock() {
            const now = new Date();
            document.getElementById('clock').innerText = now.toLocaleTimeString('en-US', { hour12: false });
        }
        setInterval(updateClock, 1000);
        updateClock();

        // --- 解析器 (保持不变) ---
        function parseScript(text) {
            const queue = [];
            let i = 0;
            const len = text.length;
            while (i < len) {
                if (text.startsWith('\\.', i)) {
                    queue.push({ type: 'wait', ms: 500 });
                    i += 2;
                } else if (text.startsWith('\\C[', i)) {
                    const colorEnd = text.indexOf(']', i);
                    if (colorEnd > -1 && text[colorEnd + 1] === '{') {
                        const contentEnd = findClosingBrace(text, colorEnd + 1);
                        if (contentEnd > -1) {
                            const color = text.substring(i + 3, colorEnd);
                            const content = text.substring(colorEnd + 2, contentEnd);
                            for (let char of content) queue.push({ type: 'char', char: char, style: `color: ${color};` });
                            i = contentEnd + 1;
                            continue;
                        }
                    }
                    queue.push({ type: 'char', char: text[i] }); i++;
                } else if (text.startsWith('\\-{', i)) {
                    const contentEnd = findClosingBrace(text, i + 2);
                    if (contentEnd > -1) {
                        const content = text.substring(i + 3, contentEnd);
                        for (let char of content) queue.push({ type: 'char', char: char, style: 'text-decoration: line-through;' });
                        i = contentEnd + 1; continue;
                    }
                    queue.push({ type: 'char', char: text[i] }); i++;
                } else if (text.startsWith('\\_{', i)) {
                    const contentEnd = findClosingBrace(text, i + 2);
                    if (contentEnd > -1) {
                        const content = text.substring(i + 3, contentEnd);
                        for (let char of content) queue.push({ type: 'char', char: char, style: 'text-decoration: underline;' });
                        i = contentEnd + 1; continue;
                    }
                    queue.push({ type: 'char', char: text[i] }); i++;
                } else {
                    queue.push({ type: 'char', char: text[i] }); i++;
                }
            }
            return queue;
        }

        function findClosingBrace(str, startIndex) {
            let depth = 0;
            for (let k = startIndex; k < str.length; k++) {
                if (str[k] === '{') depth++;
                if (str[k] === '}') {
                    depth--;
                    if (depth === 0) return k;
                }
            }
            return -1;
        }

        // --- 打字机逻辑 (保持不变) ---
        function startTypewriter(queue, callback) {
            if (typeTimer) clearTimeout(typeTimer);
            typeQueue = queue;
            typeIndex = 0;
            typeCallback = callback;
            isTyping = true;
            processNext();
        }

        function processNext() {
            if (typeIndex >= typeQueue.length) {
                isTyping = false;
                if (typeCallback) typeCallback();
                return;
            }

            const item = typeQueue[typeIndex];
            typeIndex++;

            if (item.type === 'wait') {
                typeTimer = setTimeout(processNext, item.ms);
            } else if (item.type === 'char') {
                appendCharToScreen(item);
                textElement.scrollTop = textElement.scrollHeight;
                let speed = Math.random() * 30 + 10;
                if (['.', '?', '!', '\n'].includes(item.char)) speed += 200;
                typeTimer = setTimeout(processNext, speed);
            }
        }

        function appendCharToScreen(item) {
            const span = document.createElement('span');
            span.textContent = item.char;
            span.className = 'char-span';
            if (item.style) {
                span.style.cssText = item.style;
            }
            textElement.appendChild(span);
        }

        function instantFinish() {
            if (!isTyping) return;
            clearTimeout(typeTimer);
            while (typeIndex < typeQueue.length) {
                const item = typeQueue[typeIndex];
                typeIndex++;
                if (item.type === 'char') {
                    appendCharToScreen(item);
                }
            }
            textElement.scrollTop = textElement.scrollHeight;
            isTyping = false;
            if (typeCallback) typeCallback();
        }

        document.body.addEventListener('click', (e) => {
            if (e.target.tagName === 'BUTTON') return;
            if (isTyping) {
                instantFinish();
            }
        });

        function showNode(nodeKey) {
            const node = storyNodes[nodeKey];
            if (!node) {
                console.error("Node not found:", nodeKey);
                return;
            }

            textElement.innerHTML = "";
            choicesElement.innerHTML = "";

            const queue = parseScript(node.text);

            startTypewriter(queue, () => {
                node.options.forEach(option => {
                    const button = document.createElement('button');
                    button.innerText = option.text;
                    button.onclick = (e) => {
                        e.stopPropagation();
                        showNode(option.nextNode);
                    };
                    choicesElement.appendChild(button);
                });
                textElement.scrollTop = textElement.scrollHeight;
            });
        }

        function bootSequence() {
            const bootText = "BIOS DATE 01/01/1985 14:22:56 VER 1.02\nCPU: NEC V20, SPEED: 8 MHz\n640K RAM SYSTEM... \\C[#0f0]{OK}\nLOADING CASSETTE INTERFACE\\..\\..\\..";

            const queue = parseScript(bootText);
            startTypewriter(queue, () => {
                setTimeout(() => {
                    showNode('start');
                }, 1000);
            });
        }

        // --- 初始化：先加载 JSON，成功后再启动 ---
        function initGame() {
            // 注意：fetch 不能读取本地 file:// 协议，必须使用本地服务器 (Local Server)
            fetch('./磁带主义story.json')
                .then(response => {
                    if (!response.ok) {
                        throw new Error("HTTP error " + response.status);
                    }
                    return response.json();
                })
                .then(data => {
                    storyNodes = data;
                    console.log("Story loaded successfully.");
                    // 数据加载完毕，开始播放启动动画
                    bootSequence();
                })
                .catch(err => {
                    console.error("Failed to load story.json:", err);
                    textElement.innerHTML = "\\C[red]{ERROR: CARTRIDGE NOT FOUND.}\\.\n请确保使用本地服务器 (Local Server) 运行此网页，或者 story.json 文件丢失。";
                    // 手动触发一下解析器让错误信息显示颜色
                    const queue = parseScript(textElement.innerText);
                    textElement.innerHTML = "";
                    startTypewriter(queue);
                });
        }

        window.onload = initGame;

    </script>
</body>

</html>