<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
</head>

<body style="margin:0;background:black;">
    <canvas id="c"></canvas>

    <script>
        const canvas = document.getElementById("c");
        const gl = canvas.getContext("webgl");

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        resize();
        window.addEventListener("resize", resize);

        const vertexSrc = `
attribute vec2 position;
varying vec2 vUV;
void main(){
    vUV = position * 0.5 + 0.5;
    gl_Position = vec4(position,0.0,1.0);
}
`;

        const fragmentSrc = `
precision highp float;

varying vec2 vUV;

uniform vec2 uCenter;
uniform vec2 uPointer;
uniform vec2 uResolution;
uniform float uTime;

float variation(vec2 v1, vec2 v2, float frequency, float speed, float amplitude){
    float v = dot(normalize(v1), normalize(v2));
    float waves =
        sin(v * frequency - uTime * speed) / 50.0 +
        sin(v * frequency * 3.0 - uTime * speed) / 500.0;
    return amplitude * waves;
}

vec2 fixAspect(vec2 uv, vec2 center){
    vec2 d = uv - center;
    d.x *= uResolution.x / uResolution.y;
    return d + center;
}

float drawCircle(vec2 uv, float r1, float r2, float remap_len,
                 float frequency, float speed, float amplitude){

    vec2 direct = normalize(uPointer - uCenter);
    float strength = min(length(uPointer - uCenter), 0.5) * 2.0;

    vec2 remap_pointer = direct * strength * remap_len + uCenter;

    vec2 uv_fixed = fixAspect(uv, uCenter);
    vec2 remap_fixed = fixAspect(remap_pointer, uCenter);

    vec2 uv_center = uv_fixed - uCenter;
    vec2 uv_pointer = uv_fixed - remap_fixed;

    float mask_center = step(0.0, dot(-direct, normalize(uv_center)));
    float mask_pointer = step(0.0, dot(direct, normalize(uv_pointer)));

    float len = max(
        length(uv_center) * mask_center +
        length(uv_pointer) * mask_pointer,
        abs(uv_center.x * direct.y - uv_center.y * direct.x)
    );

    vec2 back_center = uCenter - direct * 0.1;
    vec2 back_fixed = fixAspect(back_center, uCenter);

    float mask_diff = step(0.0, dot(-direct, normalize(uv_fixed - back_fixed)));
    float diff = (1.0 - mask_diff) * dot(uv_fixed - back_fixed, direct);
    diff *= diff;

    len += variation(uv_center, direct, frequency, speed, amplitude) * diff;
    len -= variation(vec2(uv_center.y, -uv_center.x),
                     direct, frequency, speed, amplitude) * diff;

    return step(r2, len) * step(len, r1);
}

void main(){

    vec2 uv = vUV;

    float strength = min(length(uPointer - uCenter), 0.5) * 2.0;
    float s = mix(0.0, 10.0, strength);

    float width = 0.0045;
    float r1 = 0.16;

    float color = drawCircle(uv, r1, r1-width, 0.12, 5.0, 7.2, s);
    color += mix(0.0,
        drawCircle(uv, r1, r1-4.0*width, 0.10, 4.0, 6.8, s),
        strength);

    float r2 = mix(r1, 0.17, strength);
    color = max(color,
        drawCircle(uv, r2, r2-width, 0.14, 6.5, 7.8, s));

    float r3 = mix(r1, 0.18, strength);
    color = max(color,
        drawCircle(uv, r3, r3-width, 0.16, 6.5, 8.4, s));

    float r4 = mix(r1, 0.19, strength);
    color = max(color,
        drawCircle(uv, r4, r4-width, 0.18, 7.0, 9.0, s));

    gl_FragColor = vec4(color, color*0.8, color*0.8, color);
}
`;

        function compile(type, source) {
            const s = gl.createShader(type);
            gl.shaderSource(s, source);
            gl.compileShader(s);
            return s;
        }

        const program = gl.createProgram();
        gl.attachShader(program, compile(gl.VERTEX_SHADER, vertexSrc));
        gl.attachShader(program, compile(gl.FRAGMENT_SHADER, fragmentSrc));
        gl.linkProgram(program);
        gl.useProgram(program);

        const buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
            -1, -1,
            1, -1,
            -1, 1,
            1, 1
        ]), gl.STATIC_DRAW);

        const position = gl.getAttribLocation(program, "position");
        gl.enableVertexAttribArray(position);
        gl.vertexAttribPointer(position, 2, gl.FLOAT, false, 0, 0);

        const uCenter = gl.getUniformLocation(program, "uCenter");
        const uPointer = gl.getUniformLocation(program, "uPointer");
        const uResolution = gl.getUniformLocation(program, "uResolution");
        const uTime = gl.getUniformLocation(program, "uTime");

        let center = [0.5, 0.5];
        let pointer = [0.5, 0.5];

        canvas.addEventListener("mousemove", e => {
            const r = canvas.getBoundingClientRect();
            pointer[0] = (e.clientX - r.left) / r.width;
            pointer[1] = 1.0 - (e.clientY - r.top) / r.height;
        });

        function render(t) {

            gl.uniform2fv(uCenter, center);
            gl.uniform2fv(uPointer, pointer);
            gl.uniform2f(uResolution, canvas.width, canvas.height);
            gl.uniform1f(uTime, t * 0.001);

            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            requestAnimationFrame(render);
        }

        requestAnimationFrame(render);

    </script>
</body>

</html>