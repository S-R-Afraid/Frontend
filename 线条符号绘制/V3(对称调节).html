<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="utf-8" />
    <title>SymmetricTile - demo</title>
    <style>
        html,
        body {
            height: 100%;
            margin: 0;
            background: #121212;
            color: #ddd;
            font-family: system-ui, Segoe UI, Roboto, Helvetica, Arial;
        }

        .controls {
            position: fixed;
            left: 12px;
            top: 12px;
            z-index: 10;
            background: rgba(0, 0, 0, 0.55);
            padding: 10px;
            border-radius: 6px;
            font-size: 13px;
        }

        label {
            display: block;
            margin-bottom: 6px;
        }

        select,
        input {
            font-size: 13px;
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            cursor: pointer;
        }
    </style>
</head>

<body>


    <canvas id="canvas"></canvas>

    <script>
        /*
          SymmetricTile class
          constructor({ canvasId, gridSize, edgesMax, edgesAttempts, symmetry })
        */
        class SymmetricTile {
            constructor({ canvasId, gridSize = 6, edgesMax = 18, edgesAttempts = 30, symmetry = 'xy' } = {}) {
                // Validate
                if (!canvasId) throw new Error('canvasId is required')
                if (!['none', 'x', 'y', 'xy'].includes(symmetry)) throw new Error('symmetry must be one of none,x,y,xy')
                if (!Number.isInteger(gridSize) || gridSize < 2) throw new Error('gridSize must be integer >= 2')

                this.canvas = document.getElementById(canvasId)
                if (!this.canvas) throw new Error('canvas element not found')
                this.ctx = this.canvas.getContext('2d')

                this.gridSize = gridSize
                this.edgesMax = edgesMax | 0
                this.edgesAttempts = edgesAttempts | 0
                this.symmetry = symmetry

                // derived domain dims depend on symmetry
                this._computeDomain()

                // generation parameters
                this.startPoint = [Math.floor(this.domainWidth / 2), Math.floor(this.domainHeight / 2)]
                this.dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]]

                // interaction & sizing
                this._bindEvents()
                this._onResize()

                // initial draw
                this.regenerate()
            }

            setParams({ gridSize, edgesMax, edgesAttempts, symmetry } = {}) {
                if (gridSize !== undefined) {
                    if (!Number.isInteger(gridSize) || gridSize < 2) throw new Error('gridSize must be integer >= 2')
                    this.gridSize = gridSize
                }
                if (edgesMax !== undefined) this.edgesMax = edgesMax | 0
                if (edgesAttempts !== undefined) this.edgesAttempts = edgesAttempts | 0
                if (symmetry !== undefined) {
                    if (!['none', 'x', 'y', 'xy'].includes(symmetry)) throw new Error('symmetry must be one of none,x,y,xy')
                    this.symmetry = symmetry
                }
                this._computeDomain()
                this.startPoint = [Math.floor(this.domainWidth / 2), Math.floor(this.domainHeight / 2)]
                this.regenerate()
            }

            _computeDomain() {
                // domainWidth/Height = number of grid nodes in basic domain
                // grid nodes indexed 0..gridSize-1
                const N = this.gridSize
                if (this.symmetry === 'none') {
                    this.domainWidth = N
                    this.domainHeight = N
                } else if (this.symmetry === 'x') {
                    this.domainWidth = N
                    this.domainHeight = Math.ceil(N / 2)
                } else if (this.symmetry === 'y') {
                    this.domainWidth = Math.ceil(N / 2)
                    this.domainHeight = N
                } else if (this.symmetry === 'xy') {
                    this.domainWidth = Math.ceil(N / 2)
                    this.domainHeight = Math.ceil(N / 2)
                }
                // prepare transforms (functions that map domain (x,y) -> full grid (X,Y))
                this.transforms = this._buildTransforms()
            }

            _buildTransforms() {
                const N = this.gridSize
                const reflectX = (x, y) => [N - 1 - x, y]
                const reflectY = (x, y) => [x, N - 1 - y]
                const reflectXY = (x, y) => [N - 1 - x, N - 1 - y]
                if (this.symmetry === 'none') {
                    return [(p) => [p[0], p[1]]] // identity
                } else if (this.symmetry === 'x') {
                    return [p => [p[0], p[1]], p => reflectY(p[0], p[1])]
                } else if (this.symmetry === 'y') {
                    return [p => [p[0], p[1]], p => reflectX(p[0], p[1])]
                } else { // xy
                    return [
                        p => [p[0], p[1]],
                        p => reflectX(p[0], p[1]),
                        p => reflectY(p[0], p[1]),
                        p => reflectXY(p[0], p[1])
                    ]
                }
            }

            _bindEvents() {
                window.addEventListener('resize', () => {
                    this._onResize()
                    this.draw()
                })
                this.canvas.addEventListener('mousedown', (e) => {
                    // regenerate on click
                    this.regenerate()
                })
            }

            _onResize() {
                // keep full-window canvas; if you want CSS scaling, adapt accordingly
                this.canvas.width = window.innerWidth
                this.canvas.height = window.innerHeight
                // decide drawable square region margin
                // we'll compute step at draw time based on gridSize
            }

            _randChoice(arr) {
                return arr[Math.floor(Math.random() * arr.length)]
            }

            // Generate path in domain coordinates: x in [0..domainWidth-1], y in [0..domainHeight-1]
            getPoints() {
                let [sx, sy] = this.startPoint
                // clamp start to domain
                let x = Math.max(0, Math.min(this.domainWidth - 1, sx | 0))
                let y = Math.max(0, Math.min(this.domainHeight - 1, sy | 0))
                const points = [[x, y]]
                const edges = {} // map "x-y" -> array of visited neighbor coords

                const getEdges = (ax, ay) => {
                    const k = ax + '-' + ay
                    if (!edges[k]) edges[k] = []
                    return edges[k]
                }

                let i = 0, count = 0
                while (i < this.edgesAttempts && count < this.edgesMax) {
                    const visited = getEdges(x, y)
                    const options = this.dirs.filter(([dx, dy]) => {
                        const nx = x + dx, ny = y + dy
                        if (nx < 0 || nx >= this.domainWidth) return false
                        if (ny < 0 || ny >= this.domainHeight) return false
                        // avoid repeating same edge
                        if (visited.find(p => p[0] === nx && p[1] === ny)) return false
                        return true
                    })

                    if (!options.length) break

                    const [dx, dy] = this._randChoice(options)
                    const px = x, py = y
                    x += dx; y += dy

                    visited.push([x, y])
                    getEdges(x, y).push([px, py])

                    points.push([x, y])
                    count++; i++
                }

                return points
            }

            // Draw helper: map domain grid node [x,y] to pixel coordinates in drawable square
            _nodeToPixel(nodeX, nodeY, drawableSize, offsetX, offsetY) {
                // grid nodes are 0..gridSize-1 => step = drawableSize / (gridSize - 1)
                const N = this.gridSize
                const step = drawableSize / (N - 1)
                const px = offsetX + nodeX * step
                const py = offsetY + nodeY * step
                return [px, py]
            }

            // draw all mirrored segments based on domain path
            drawPathWithTransforms(points, drawableSize, offsetX, offsetY) {
                const ctx = this.ctx
                const transforms = this.transforms
                const N = this.gridSize
                if (!points || points.length < 2) return

                ctx.beginPath()
                for (let idx = 1; idx < points.length; idx++) {
                    const a = points[idx - 1]
                    const b = points[idx]

                    // for each transform, map a and b, dedupe identical pairs
                    for (let t = 0; t < transforms.length; t++) {
                        const f = transforms[t]
                        const A = f(a)
                        const B = f(b)

                        // A and B are integer node coords in full grid space
                        // only draw if different
                        if (A[0] === B[0] && A[1] === B[1]) continue

                        // compute pixel positions
                        const [ax, ay] = this._nodeToPixel(A[0], A[1], drawableSize, offsetX, offsetY)
                        const [bx, by] = this._nodeToPixel(B[0], B[1], drawableSize, offsetX, offsetY)

                        ctx.moveTo(ax, ay)
                        ctx.lineTo(bx, by)
                    }
                }
                ctx.stroke()
            }

            // regenerate: generate domain points and store
            regenerate() {
                this.domainPoints = this.getPoints()
                this.draw()
            }

            draw() {
                const ctx = this.ctx
                ctx.clearRect(0, 0, this.canvas.width, this.canvas.height)
                ctx.lineWidth = 3
                ctx.strokeStyle = '#ffffff'
                ctx.lineCap = 'round'
                ctx.lineJoin = 'round'

                // compute drawable square size: fit into canvas while leaving small padding
                const padding = Math.min(this.canvas.width, this.canvas.height) * 0.06
                const maxSize = Math.min(this.canvas.width, this.canvas.height) - padding * 2
                // we will draw full grid into a square of size = maxSize
                const drawableSize = maxSize
                const offsetX = (this.canvas.width - drawableSize) / 2
                const offsetY = (this.canvas.height - drawableSize) / 2

                // draw background grid optional (commented out)
                // this._drawGrid(drawableSize, offsetX, offsetY)

                // now draw mirrored path(s)
                this.drawPathWithTransforms(this.domainPoints, drawableSize, offsetX, offsetY)
            }

            // optional helper to draw grid lines for debugging
            _drawGrid(drawableSize, offsetX, offsetY) {
                const ctx = this.ctx
                const N = this.gridSize
                const step = drawableSize / (N - 1)
                ctx.save()
                ctx.strokeStyle = 'rgba(255,255,255,0.06)'
                ctx.lineWidth = 1
                ctx.beginPath()
                for (let i = 0; i < N; i++) {
                    // vertical
                    const x = offsetX + i * step
                    ctx.moveTo(x, offsetY)
                    ctx.lineTo(x, offsetY + drawableSize)
                    // horizontal
                    const y = offsetY + i * step
                    ctx.moveTo(offsetX, y)
                    ctx.lineTo(offsetX + drawableSize, y)
                }
                ctx.stroke()
                ctx.restore()
            }
        } // end class

        // -------------------- usage demo --------------------

        const tile = new SymmetricTile({
            canvasId: 'canvas',
            gridSize: 16,//边长（必须是偶数）
            edgesMax: 100,//路径最大长度
            edgesAttempts: 300,//路径尝试次数
            symmetry: 'xy' // 对称性：none, x, y, xy
        })



    </script>
</body>

</html>