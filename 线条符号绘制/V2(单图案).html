<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <title>Single Symmetric Tile</title>
    <style>
        html,
        body {
            margin: 0;
            background: #121212;
            overflow: hidden;
        }

        canvas {
            display: block;
            cursor: pointer;
        }
    </style>
</head>

<body>

    <canvas id="canvas"></canvas>

    <script>
        /* ======================
           参数配置
        ====================== */

        const P = {
            gridSize: 20,        // 4 / 6 / 8 / 10 ...
            edgesMax: 100,
            edgesAttempts: 300,
            startPoint: [1, 1],
        }

        /* 推导象限网格 */
        P.innerGrid = P.gridSize / 2

        /* ======================
           Canvas 初始化
        ====================== */

        const canvas = document.getElementById('canvas')
        const ctx = canvas.getContext('2d')

        function resize() {
            canvas.width = window.innerWidth
            canvas.height = window.innerHeight
        }
        window.addEventListener('resize', () => {
            resize()
            draw()
        })
        resize()

        canvas.addEventListener('mousedown', regenerate)

        /* ======================
           工具
        ====================== */

        const DIRS = [
            [1, 0],
            [-1, 0],
            [0, 1],
            [0, -1]
        ]

        function random(arr) {
            return arr[Math.floor(Math.random() * arr.length)]
        }

        /* ======================
           路径生成（单 tile）
        ====================== */

        function getPoints() {
            let [x, y] = P.startPoint
            const points = [[x, y]]
            const edges = {}

            const getEdges = (x, y) => {
                const k = `${x}-${y}`
                if (!edges[k]) edges[k] = []
                return edges[k]
            }

            let i = 0
            let count = 0

            while (i < P.edgesAttempts && count < P.edgesMax) {
                const visited = getEdges(x, y)

                const options = DIRS.filter(([dx, dy]) => {
                    const nx = x + dx
                    const ny = y + dy
                    if (nx < 0 || nx > P.innerGrid) return false
                    if (ny < 0 || ny > P.innerGrid) return false
                    if (visited.find(p => p[0] === nx && p[1] === ny)) return false
                    return true
                })

                if (!options.length) break

                const [dx, dy] = random(options)
                const px = x, py = y
                x += dx
                y += dy

                visited.push([x, y])
                getEdges(x, y).push([px, py])

                points.push([x, y])
                count++
                i++
            }

            return points
        }

        /* ======================
           绘制（对称）
        ====================== */

        function drawQuadrant(points, size) {
            const step = size / P.innerGrid
            ctx.beginPath()
            for (let i = 1; i < points.length; i++) {
                const a = points[i - 1]
                const b = points[i]
                ctx.moveTo(a[0] * step, a[1] * step)
                ctx.lineTo(b[0] * step, b[1] * step)
            }
            ctx.stroke()
        }

        function drawSymmetric(points, size) {
            const half = size / 2

            ctx.save()
            ctx.translate(half, half)

            ctx.scale(1, -1)
            drawQuadrant(points, half)

            ctx.scale(1, -1)
            drawQuadrant(points, half)

            ctx.scale(-1, 1)
            drawQuadrant(points, half)

            ctx.scale(1, -1)
            drawQuadrant(points, half)

            ctx.restore()
        }

        /* ======================
           绘制调度（只画一个）
        ====================== */

        let currentPoints = null

        function regenerate() {
            currentPoints = getPoints()
            draw()
        }

        function draw() {
            if (!currentPoints) return

            ctx.clearRect(0, 0, canvas.width, canvas.height)
            ctx.strokeStyle = '#ffffff'
            ctx.lineWidth = 3

            const size = Math.min(canvas.width, canvas.height) * 0.8

            ctx.save()
            ctx.translate(
                (canvas.width - size) / 2,
                (canvas.height - size) / 2
            )
            drawSymmetric(currentPoints, size)
            ctx.restore()
        }

        /* ======================
           启动
        ====================== */

        regenerate()
    </script>

</body>

</html>