<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="utf-8">
    <title>p5.js + ShaderToy 标准模板（已修复）</title>
    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
        }

        canvas {
            display: block;
        }
    </style>
</head>

<body>

    <script src="https://cdn.jsdelivr.net/npm/p5@1.9.3/lib/p5.min.js"></script>

    <script>
        /* ======================= ShaderToy 代码 ======================= */

        const shadertoy = `

float random(vec2 st){
    return fract(sin(dot(st,vec2(12.9898,78.233))) * 43758.5453123);
}

vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x,289.0);}
vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}
vec3 fade(vec3 t){return t*t*t*(t*(t*6.0-15.0)+10.0);}

float cnoise(vec3 P){
    vec3 Pi0 = floor(P);
    vec3 Pi1 = Pi0 + 1.0;
    Pi0 = mod(Pi0,289.0);
    Pi1 = mod(Pi1,289.0);
    vec3 Pf0 = fract(P);
    vec3 Pf1 = Pf0 - 1.0;

    vec4 ix = vec4(Pi0.x,Pi1.x,Pi0.x,Pi1.x);
    vec4 iy = vec4(Pi0.yy,Pi1.yy);
    vec4 iz0 = Pi0.zzzz;
    vec4 iz1 = Pi1.zzzz;

    vec4 ixy = permute(permute(ix)+iy);
    vec4 ixy0 = permute(ixy+iz0);
    vec4 ixy1 = permute(ixy+iz1);

    vec4 gx0 = ixy0/7.0;
    vec4 gy0 = fract(floor(gx0)/7.0)-0.5;
    gx0 = fract(gx0);
    vec4 gz0 = 0.5-abs(gx0)-abs(gy0);
    vec4 sz0 = step(gz0,vec4(0.0));
    gx0 -= sz0*(step(0.0,gx0)-0.5);
    gy0 -= sz0*(step(0.0,gy0)-0.5);

    vec4 gx1 = ixy1/7.0;
    vec4 gy1 = fract(floor(gx1)/7.0)-0.5;
    gx1 = fract(gx1);
    vec4 gz1 = 0.5-abs(gx1)-abs(gy1);
    vec4 sz1 = step(gz1,vec4(0.0));
    gx1 -= sz1*(step(0.0,gx1)-0.5);
    gy1 -= sz1*(step(0.0,gy1)-0.5);

    vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
    vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
    vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
    vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
    vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
    vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
    vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
    vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);

    vec4 norm0 = taylorInvSqrt(vec4(dot(g000,g000),dot(g010,g010),dot(g100,g100),dot(g110,g110)));
    g000 *= norm0.x;
    g010 *= norm0.y;
    g100 *= norm0.z;
    g110 *= norm0.w;

    vec4 norm1 = taylorInvSqrt(vec4(dot(g001,g001),dot(g011,g011),dot(g101,g101),dot(g111,g111)));
    g001 *= norm1.x;
    g011 *= norm1.y;
    g101 *= norm1.z;
    g111 *= norm1.w;

    float n000 = dot(g000,Pf0);
    float n100 = dot(g100,vec3(Pf1.x,Pf0.yz));
    float n010 = dot(g010,vec3(Pf0.x,Pf1.y,Pf0.z));
    float n110 = dot(g110,vec3(Pf1.xy,Pf0.z));
    float n001 = dot(g001,vec3(Pf0.xy,Pf1.z));
    float n101 = dot(g101,vec3(Pf1.x,Pf0.y,Pf1.z));
    float n011 = dot(g011,vec3(Pf0.x,Pf1.yz));
    float n111 = dot(g111,Pf1);

    vec3 f = fade(Pf0);
    vec4 nz = mix(vec4(n000,n100,n010,n110),vec4(n001,n101,n011,n111),f.z);
    vec2 nyz = mix(nz.xy,nz.zw,f.y);
    return 2.2 * mix(nyz.x,nyz.y,f.x);
}

const float PI = 3.1415926;

vec2 rotate(vec2 p, float a){
    float c = cos(a), s = sin(a);
    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);
}

void mainImage(out vec4 fragColor, in vec2 fragCoord){

    // -------- 背景色 --------
    vec3 bgColor = vec3(43.0, 43.0, 43.0) / 255.0;

    vec2 center = iResolution * 0.5;
    vec2 uv = fragCoord - center;
    float r = length(uv);

    // -------- 全屏旋转（不裁剪）--------
    float twist =
        r * 0.002 +
        cnoise(vec3(r * 0.06 - iTime * 3.0, 0.0, iTime * 0.25)) +
        iTime * 0.5;

    uv = rotate(uv, twist);

    // -------- 扇区 --------
    const float PI = 3.1415926;
    float angle = atan(uv.y, uv.x);
    float sector = floor((angle + PI) / (2.0 * PI / 5.0));

    // -------- 前景亮度 --------
    float fg = sector / 5.0;
    fg += random(fragCoord * 0.5) * 0.15;

    vec3 fgColor = vec3(fg);

    // -------- 前景权重（决定“哪里明显”）--------
    // 这里不是裁剪，而是控制叠加强度
    float weight = smoothstep(
        0.0,
        min(iResolution.x, iResolution.y) * 0.7,
        r
    );

    // -------- 叠加 --------
    vec3 color = mix(bgColor, fgColor, weight);

    fragColor = vec4(color, 1.0);
}

`;

        /* ======================= Shader 包装 ======================= */

        const frag = `
#ifdef GL_ES
precision mediump float;
#endif

uniform vec2 iResolution;
uniform vec2 iMouse;
uniform float iTime;

${shadertoy}

void main(){
    mainImage(gl_FragColor, gl_FragCoord.xy);
}
`;

        const vert = `
#ifdef GL_ES
precision highp float;
#endif

attribute vec3 aPosition;

uniform mat4 uModelViewMatrix;
uniform mat4 uProjectionMatrix;

void main(){
    gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aPosition, 1.0);
}
`;

        /* ======================= p5.js ======================= */

        let shaderProgram;

        function setup() {
            createCanvas(windowWidth, windowHeight, WEBGL);
            noStroke();
            shaderProgram = createShader(vert, frag);
        }

        function draw() {
            shader(shaderProgram);
            shaderProgram.setUniform('iResolution', [width, height]);
            shaderProgram.setUniform('iTime', millis() * 0.001);
            shaderProgram.setUniform('iMouse', [mouseX, height - mouseY]);

            rect(-width / 2, -height / 2, width, height);
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
        }
    </script>

</body>

</html>